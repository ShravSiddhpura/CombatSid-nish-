<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Combat Arena</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: "Poppins", sans-serif; }

    #startScreen, #pauseScreen, #gameOverScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: white;
      background: radial-gradient(circle at center, rgba(0,0,0,0.9), rgba(0,0,0,1));
      text-align: center;
      z-index: 10;
    }

    h1 {
      font-size: 3em;
      letter-spacing: 2px;
      color: #00aaff;
      text-shadow: 0 0 20px #00aaff;
    }

    .btn {
      margin: 10px;
      padding: 10px 30px;
      background: #00aaff;
      border: none;
      border-radius: 10px;
      font-size: 1.2em;
      color: white;
      cursor: pointer;
      transition: 0.3s;
    }

    .btn:hover { background: #0088cc; }
    .controls { margin-top: 20px; font-size: 1em; color: #ccc; }
    #pauseScreen, #gameOverScreen { display: none; background: rgba(0,0,0,0.6); z-index: 5; }
  </style>
</head>
<body>

<div id="startScreen">
  <h1>‚öîÔ∏è COMBAT ARENA ‚öîÔ∏è</h1>
  <button class="btn" id="startBtn">Start Game</button>
  <div class="controls">
    <p><b>Controls:</b></p>
    <p>W / A / S / D ‚Äî Move</p>
    <p>SPACE ‚Äî Shoot</p>
    <p>P ‚Äî Pause / Resume</p>
  </div>
</div>

<div id="pauseScreen">
  <h1>‚è∏Ô∏è Paused</h1>
  <button class="btn" id="resumeBtn">Resume</button>
</div>

<div id="gameOverScreen">
  <h1 id="gameOverText">Game Over</h1>
  <button class="btn" id="restartBtn">Restart</button>
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.155/build/three.module.js";

let scene, camera, renderer, player, bullets = [], enemies = [], enemyBullets = [], walls = [];
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let clock = new THREE.Clock();
let gamePaused = false, gameStarted = false, playerAlive = true;

const speed = 10;
const bulletSpeed = 20;
const enemySpeed = 3;
const enemyFireInterval = 2000;
let lastEnemyFire = 0;

scene = new THREE.Scene();
scene.background = new THREE.Color(0x111122);

camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(15, 20, 15);

renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0x404040));
const light = new THREE.DirectionalLight(0xffffff, 1.2);
light.position.set(10, 20, 10);
scene.add(light);

// ===== FLOOR =====
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(120, 120),
  new THREE.MeshPhongMaterial({ color: 0x333333 })
);
floor.rotation.x = -Math.PI / 2;
scene.add(floor);

// ===== WALLS =====
const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x555555 });
function createWall(x, z, w, h) {
  const wall = new THREE.Mesh(new THREE.BoxGeometry(w, 5, h), wallMaterial);
  wall.position.set(x, 2.5, z);
  scene.add(wall);
  walls.push(wall);
}
createWall(0, -50, 120, 2);
createWall(0, 50, 120, 2);
createWall(-50, 0, 2, 100);
createWall(50, 0, 2, 100);
createWall(0, 0, 40, 2);
createWall(-20, 20, 30, 2);
createWall(20, -20, 30, 2);

// ===== HUMAN MODEL =====
function createHuman(color) {
  const group = new THREE.Group();
  const bodyMat = new THREE.MeshPhongMaterial({ color });
  const torso = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3, 1), bodyMat);
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.75, 8, 8), new THREE.MeshPhongMaterial({ color: 0xffffff }));
  head.position.y = 2.2;
  const armGeo = new THREE.BoxGeometry(0.4, 1.8, 0.4);
  const leftArm = new THREE.Mesh(armGeo, bodyMat);
  const rightArm = new THREE.Mesh(armGeo, bodyMat);
  leftArm.position.set(-1.2, 0.5, 0);
  rightArm.position.set(1.2, 0.5, 0);
  const legGeo = new THREE.BoxGeometry(0.5, 1.8, 0.5);
  const leftLeg = new THREE.Mesh(legGeo, bodyMat);
  const rightLeg = new THREE.Mesh(legGeo, bodyMat);
  leftLeg.position.set(-0.5, -2, 0);
  rightLeg.position.set(0.5, -2, 0);
  group.add(torso, head, leftArm, rightArm, leftLeg, rightLeg);
  group.userData = { limbs: [leftArm, rightArm, leftLeg, rightLeg] };
  return group;
}

player = createHuman(0x00aaff);
player.position.set(0, 2.5, 10);
scene.add(player);

const arrow = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), player.position, 3, 0xffff00);
scene.add(arrow);

// ===== ENEMIES =====
function spawnEnemy(x, z) {
  const enemy = createHuman(0xff3333);
  enemy.position.set(x, 2.5, z);
  scene.add(enemy);
  enemies.push(enemy);
}
spawnEnemy(-25, -25);
spawnEnemy(25, 25);
spawnEnemy(-30, 30);
spawnEnemy(30, -20);

// ===== SHOOTING =====
function shoot() {
  if (!playerAlive) return;
  const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
  bullet.position.copy(player.position);
  const dir = new THREE.Vector3(Math.sin(player.rotation.y), 0, Math.cos(player.rotation.y)).normalize();
  bullet.userData = { dir, from: "player" };
  scene.add(bullet);
  bullets.push(bullet);
}

function enemyShoot(enemy) {
  const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
  bullet.position.copy(enemy.position);
  const dir = player.position.clone().sub(enemy.position).normalize();
  bullet.userData = { dir, from: "enemy" };
  scene.add(bullet);
  enemyBullets.push(bullet);
}

// ===== INPUT =====
document.addEventListener("keydown", (e) => {
  if (!gameStarted) return;
  if (e.code === "KeyW") moveForward = true;
  if (e.code === "KeyS") moveBackward = true;
  if (e.code === "KeyA") moveLeft = true;
  if (e.code === "KeyD") moveRight = true;
  if (e.code === "Space") shoot();
  if (e.code === "KeyP") togglePause();
});
document.addEventListener("keyup", (e) => {
  if (e.code === "KeyW") moveForward = false;
  if (e.code === "KeyS") moveBackward = false;
  if (e.code === "KeyA") moveLeft = false;
  if (e.code === "KeyD") moveRight = false;
});

// ===== COLLISION =====
function collides(pos, radius = 1.5) {
  for (let wall of walls) {
    const wx = wall.position.x, wz = wall.position.z;
    const halfW = wall.geometry.parameters.width / 2, halfH = wall.geometry.parameters.depth / 2;
    if (pos.x + radius > wx - halfW && pos.x - radius < wx + halfW &&
        pos.z + radius > wz - halfH && pos.z - radius < wz + halfH)
      return true;
  }
  return false;
}

function bulletHitsWall(bullet) {
  for (let wall of walls) {
    const wx = wall.position.x, wz = wall.position.z;
    const halfW = wall.geometry.parameters.width / 2, halfH = wall.geometry.parameters.depth / 2;
    if (bullet.position.x > wx - halfW && bullet.position.x < wx + halfW &&
        bullet.position.z > wz - halfH && bullet.position.z < wz + halfH)
      return true;
  }
  return false;
}

// ===== ANIMATE =====
function animate() {
  requestAnimationFrame(animate);
  if (gamePaused || !gameStarted || !playerAlive) return;

  const delta = clock.getDelta();
  let dir = new THREE.Vector3();

  if (moveForward) dir.z -= 1;
  if (moveBackward) dir.z += 1;
  if (moveLeft) dir.x -= 1;
  if (moveRight) dir.x += 1;
  dir.normalize();

  if (dir.length() > 0) {
    player.rotation.y = Math.atan2(dir.x, dir.z);
    const nextPos = player.position.clone().add(dir.clone().multiplyScalar(speed * delta));
    if (!collides(nextPos)) player.position.copy(nextPos);

    // smooth walk animation
    const limbs = player.userData.limbs;
    const t = performance.now() / 250;
    limbs.forEach((limb, i) => {
      const phase = i % 2 === 0 ? 0 : Math.PI;
      limb.rotation.x = Math.sin(t + phase) * 0.5;
    });
  }

  const camOffset = new THREE.Vector3(10, 15, 15);
  camera.position.lerp(player.position.clone().add(camOffset), 0.1);
  camera.lookAt(player.position);

  arrow.position.copy(player.position);
  arrow.setDirection(new THREE.Vector3(Math.sin(player.rotation.y), 0, Math.cos(player.rotation.y)));

  // Move bullets (player)
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.position.add(b.userData.dir.clone().multiplyScalar(bulletSpeed * delta));
    if (bulletHitsWall(b)) { scene.remove(b); bullets.splice(i, 1); continue; }
    for (let j = enemies.length - 1; j >= 0; j--) {
      if (b.position.distanceTo(enemies[j].position) < 1.5) {
        scene.remove(enemies[j]); enemies.splice(j, 1);
        scene.remove(b); bullets.splice(i, 1);
        if (enemies.length === 0) endGame(true);
        break;
      }
    }
  }

  // Enemy logic
  enemies.forEach((e) => {
    const dir = player.position.clone().sub(e.position).normalize();
    const next = e.position.clone().add(dir.multiplyScalar(enemySpeed * delta));
    if (!collides(next)) e.position.copy(next);
    e.lookAt(player.position);
    const limbs = e.userData.limbs;
    const t = performance.now() / 250;
    limbs.forEach((limb, i) => {
      const phase = i % 2 === 0 ? 0 : Math.PI;
      limb.rotation.x = Math.sin(t + phase) * 0.5;
    });
  });

  // Enemy shooting
  if (performance.now() - lastEnemyFire > enemyFireInterval && enemies.length > 0) {
    lastEnemyFire = performance.now();
    enemies.forEach(e => enemyShoot(e));
  }

  // Enemy bullet movement
  for (let i = enemyBullets.length - 1; i >= 0; i--) {
    const b = enemyBullets[i];
    b.position.add(b.userData.dir.clone().multiplyScalar(bulletSpeed * delta));
    if (bulletHitsWall(b)) { scene.remove(b); enemyBullets.splice(i, 1); continue; }
    if (b.position.distanceTo(player.position) < 1.2) {
      scene.remove(b);
      enemyBullets.splice(i, 1);
      endGame(false);
      return;
    }
  }

  renderer.render(scene, camera);
}

// ===== GAME FLOW =====
document.getElementById("startBtn").addEventListener("click", () => {
  document.getElementById("startScreen").style.display = "none";
  gameStarted = true; playerAlive = true; clock.start(); animate();
});
document.getElementById("resumeBtn").addEventListener("click", togglePause);
document.getElementById("restartBtn").addEventListener("click", restartGame);

function togglePause() {
  if (!gameStarted) return;
  gamePaused = !gamePaused;
  document.getElementById("pauseScreen").style.display = gamePaused ? "flex" : "none";
  if (!gamePaused) clock.start();
}

function endGame(victory) {
  playerAlive = false;
  document.getElementById("gameOverText").innerText = victory ? "üéâ You Win!" : "üíÄ Game Over!";
  document.getElementById("gameOverScreen").style.display = "flex";
}

function restartGame() {
  window.location.reload();
}
</script>
</body>
</html>
